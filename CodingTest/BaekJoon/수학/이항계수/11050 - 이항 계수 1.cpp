/*
 *11050 - 이항 계수 1
 *
 *nCr을 구하는 문제이다.
 *
 *해를 구하는 방법은 입력받은 N과 K에 대하여
 *N-K와 K중 작은 값을 r로 선택한다.
 *
 *이후 N부터 차례로 1씩 낮춰가며 r개 만큼의 숫자를 곱해나가고
 *이것을 r!으로 나누어주면 된다.
 *
 *위의 방식그대로 구현한다면 for을 두번 구성해
 *Result 변수에 곱하는 작업과 나누는 작업을 따로 구성하게될 것이다.
 *
 *하지만 이렇게 되면 곱하는 작업중 쉽게 오버플로우가 발생한다.
 *게다가 반복문을 두번이 아닌 한번에 계산을 완료가능하다.
 *
 *5C2를 예로 든다면 Result을 1로 시작하고
 *Result에 5를 곱하고
 *Result를 1로 나눈다 ---- 반복문 종료
 *Result에 4를 곱하고
 *Result를 2로 나눈다 ---- 반복문 종료
 *
 *위와 같이 진행한다.
 *
 *궁금한점이 있다
 *
 *왜 곱하는 작업은 N부터 시작이고,
 *나누는 작업은 R부터 시작이 아닌 1부터 시작하는가?
 *
 *물론 R부터 시작하면 5는 2로 나누어지지 않으므로 간단하게 문제가 발생함을 알 수 있다.
 *
 *그렇다면 이제는 왜 1부터 나누어나가면 문제가 발생하지 않았던 것인지 궁금해진다.
 *
 *한번 잘 생각해보자.
 *
 *1부터 시작한다면 어떤 수가 와도 1로 나누면 반드시 나누어 진다.
 *2로 나누는수는 확정적으로 앞 수에서 홀수와 짝수가 무조건 존재하므로 짝수를 2로 나눌 수 있다
 *3도 마찬가지로 1의 배수 2의 배수 3의 배수가 확정적으로 존재하므로 3으로 나누어진다
 *
 *위의 규칙이 숨겨져 있던 것이다!
 *
 *이제 코드를 작성하고 정답을 받아내자.
 */

#include <iostream>

using namespace std;

int GetCombination(int N, int K)
{
	int Result = 1;
	int R = min(K, N - K);
	for (int i = 0; i < R; i++)
	{
		Result *= N - i;
		Result /= i + 1;
	}
	return Result;
}

int main()
{
	cin.tie(nullptr);
	ios_base::sync_with_stdio(false);

	int N = 0, K = 0;
	cin >> N >> K;
	cout << GetCombination(N, K);

	return 0;
}