/*
 *10844 - 쉬운 계단 수
 *
 *DP를 2차원배열로 기록한다는 발상을 떠올리는게 어려웠다.
 *
 *왜 2차원 배열을 사용하는지 알아보자
 *
 *
 *수열의 길이--------1	2	3	4	... 5
 *끝의 자리------0	0	1	1	3	... 이전결과 끝자리 1이된 경우의 수
 *				1	1	1	3	4	... 이전결과 끝자리 0, 2이된 경우의 수
 *				2	1	2	3	7	... 이전결과 끝자리 1, 3이된 경우의 수
 *				3	1	2	4	7	... 이전결과 끝자리 2, 4이된 경우의 수
 *				4	1	2	4	8	... 이전결과 끝자리 3, 5이된 경우의 수
 *				5	1	2	4	8	... 이전결과 끝자리 4, 6이된 경우의 수
 *				6	1	2	4	8	... 이전결과 끝자리 5, 7이된 경우의 수
 *				7	1	2	4	7	... 이전결과 끝자리 6, 8이된 경우의 수
 *				8	1	2	3	6	... 이전결과 끝자리 7, 9이된 경우의 수
 *				9	1	1	2	3	... 이전결과 끝자리 8이된 경우의 수
 *총 합----------	9	17	32	61  ... 위의 값들의 총합
 *
 *위와 같은 규칙을 가지게 된다.
 *
 *즉, DP배열을 [자릿수][마지막 번호숫자]로 만들어 위와 같은 규칙으로 BottomUp 한다.
 *
 *특수 조건
 *N은 100까지 입력받을 수 있지만 50만되도 이미 DP에 기록될 값들이 10억을 넘어간다.
 *
 *때문에 값의 오버플로우에 유의해야 한다.
 *
 *마침 문제에서 이를 방지하기위해
 *제약조건에 10억으로 나눈 수를 출력해야하는 조건이 있다.
 *
 *DP배열을 기록할때(덧셈 시) 10억으로 나누어주는 작업을 해준다
 *총합을 구할때도 마찬가지로 처리를 해준다.
 *
 *
 */

#include <iostream>
#define INF 1000000000

using namespace std;

int DP[101][10]{};

void Initialize()
{
	for (int i = 1; i <= 9; i++)
	{
		DP[1][i] = 1;
	}
}

int main()
{
	cin.tie(nullptr);
	ios_base::sync_with_stdio(false);

	int N = 0;
	int result = 0;
	cin >> N;

	Initialize();

	for (int i = 2; i <= N; i++)
	{
		DP[i][0] = DP[i - 1][1];
		DP[i][9] = DP[i - 1][8];
		for (int j = 1; j < 9; j++)
		{
			DP[i][j] = (DP[i - 1][j - 1] + DP[i - 1][j + 1]) % INF;
		}
	}

	for (int i = 0; i <= 9; i++)
	{
		result = (result + DP[N][i]) % INF;
	}
	cout << result;

	return 0;
}